(* my c compiler parser ebnf list *)
(* opt = [] repeat = {} *)
(* HEAD *)
translation-unit
        = { external-declaration };

external-declaration
        = function-definition
        | declaration;

function-definition = declaration-specifiers, identifier, "(", parameter-type-list, ")", compound-statement;

(* STATEMENTS *)
statement
        = compound-statement
        | expression-statement
        | iteration-statement
        | jump-statement;

compound-statement
        = "{", { block-item }, "}";

block-item
        = declaration
        | statement;

expression-statement
        = [ expression ], ";";

selection-statement
        = "if", "(", expression, ")", statement
        | "if", "(", expression, ")", statement, "else", statement;

iteration-statement
        = "while", "(", expression, ")", statement
        | "for", "(", [ expression ], ";", [ expression ], ";", [ expression ], ")", statement
        | "for", "(", declaration, [ expression ], ";", [ expression ], ")", statement;

jump-statement
        = "return", [ expression ], ";";

(* DECLARATIONS *)
declaration
        = declaration-specifiers, init-declarator, ";";

declaration-specifiers
        = { storage-class-specifier | type-specifier }, [pointer];

init-declarator
        = declarator
        | declarator, "=", initializer;

storage-class-specifier
        = "typedef"
        | "auto";

type-specifier
        = "char"
        | "short"
        | "int"
        | "long"
        | "signed"
        | "unsigned"
        | "bool"
        | "_Bool"
        | struct-or-union-specifier
        | typedef-name;

struct-or-union-specifier
        = struct-or-union, [ identifier ], "{", { struct-declaration }, "}"
        | struct-or-union, identifier;

struct-or-union
        = "struct"
        | "union";

struct-declaration
        = specifier-qualifier-list, struct-declarator, ";";

specifier-qualifier-list
        = { type-specifier }, {pointer};

struct-declarator
        = declarator;

declarator
        = direct-declarator;

direct-declarator
        = identifier, [ "[", constant, "]" ];

pointer
        = { "*" };

parameter-type-list
        = parameter-declaration, { ",", parameter-declaration }, [ "," ];

parameter-declaration
        = declaration-specifiers, declarator;

typedef-name
        = identifier;

initializer
        = assignment-expression;

(* EXPRESSIONS *)
expression
        = assignment-expression;

assignment-expression
        = conditional-expression
        | conditional-expression, assignment-operator, assignment-expression;

assignment-operator
        = "=";

conditional-expression
        = logical-OR-expression;

logical-OR-expression
        = logical-AND-expression;

logical-AND-expression
        = inclusive-OR-expression;

inclusive-OR-expression
        = exclusive-OR-expression;

exclusive-OR-expression
        = AND-expression;

AND-expression
        = equality-expression;

equality-expression
        = relational-expression, { ( "=="
        | "!=" ), relational-expression };

relational-expression
        = shift-expression, { ( "<"
        | ">"
        | "<="
        | ">=" ), shift-expression };

shift-expression
        = additive-expression;

additive-expression
        = multiplicative-expression, { ( "+"
        | "-" ), multiplicative-expression };

multiplicative-expression
        = cast-expression, { ( "*"
        | "/" ), cast-expression };

cast-expression
        = unary-expression;

unary-expression
        = postfix-expression
        | unary-operator, cast-expression
        | "sizeof", unary-expression;

unary-operator
        = "&"
        | "*"
        | "+"
        | "-";

postfix-expression
        = primary-expression
        | postfix-expression, ( "[", expression, "]"
        | "(", { assignment-expression }, ")"
        | ".", identifier
        | "->", identifier );

primary-expression
        = identifier [ "(", { assignment-expression }, ")" ]
        | constant
        | string-literal
        | "(", expression, ")";